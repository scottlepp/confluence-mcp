/**
 * Integration tests for the markdown page tools.
 *
 * These tests hit the real Confluence API using credentials from .env.local.
 * They exercise the full create → read → update → read → delete lifecycle
 * for both storage-format and ADF-format markdown tools.
 *
 * Target space: "Scotts" (ID 5353898365)
 *
 * Run with:  npx vitest run tests/integration
 */

import { describe, it, expect, afterAll, beforeAll } from "vitest";
import { readFileSync } from "fs";
import { resolve } from "path";
import { getConfig } from "../../src/config.js";
import { ConfluenceClient } from "../../src/auth/confluence-client.js";
import { handlePageTool } from "../../src/tools/pages.js";

// ─── Configuration ───────────────────────────────────────────────────────────

const SPACE_ID = "5353898365"; // "Scotts" space
const TIMESTAMP = new Date().toISOString().replace(/[:.]/g, "-");

// Check if env vars are available for integration tests
function hasConfluenceEnv(): boolean {
  try {
    getConfig();
    return true;
  } catch {
    return false;
  }
}

// ─── Test Data ───────────────────────────────────────────────────────────────

const shortMarkdown = readFileSync(
  resolve(__dirname, "../data/sample-short.md"),
  "utf-8"
);

const longMarkdown = readFileSync(
  resolve(__dirname, "../data/sample-long.md"),
  "utf-8"
);

const simpleMermaidMarkdown = `# Mermaid Integration Test

This page tests Mermaid diagram rendering via the MCP tools.

## Sequence Diagram

\`\`\`mermaid
sequenceDiagram
    participant Agent as AI Agent
    participant MCP as MCP Server
    participant API as Confluence API
    Agent->>MCP: Tool Request
    MCP->>API: REST Call
    API-->>MCP: Response
    MCP-->>Agent: Result
\`\`\`

## Flowchart

\`\`\`mermaid
graph LR
    A[Markdown Input] --> B[Converter]
    B --> C{Format?}
    C -->|Storage| D[XHTML Output]
    C -->|ADF| E[JSON Output]
    D --> F[Confluence API]
    E --> F
\`\`\`

## Code Block

\`\`\`typescript
const result = await handlePageTool(client, "confluence_create_page_from_markdown", {
  spaceId: "5353898365",
  title: "Test Page",
  markdown: "# Hello World",
});
\`\`\`

## Table

| Tool | Format | Description |
| ---- | ------ | ----------- |
| create_page_from_markdown | Storage | XHTML via marked renderer |
| update_page_from_markdown | Storage | XHTML via marked renderer |
| create_page_from_markdown_adf | ADF | JSON via marked lexer |
| update_page_from_markdown_adf | ADF | JSON via marked lexer |

---

*Generated by integration test at ${TIMESTAMP}*
`;

const updateMarkdown = `# Updated Page

This page was **updated** via the markdown tool.

- Item A
- Item B
- Item C

> This content was modified by the integration test.

*Updated at ${TIMESTAMP}*
`;

// ─── Test Helpers ────────────────────────────────────────────────────────────

interface PageResult {
  id: string;
  title: string;
  status: string;
  spaceId: string;
  version: { number: number };
  body?: {
    storage?: { value: string };
    atlas_doc_format?: { value: string };
  };
}

// ─── Integration Tests ──────────────────────────────────────────────────────

describe.runIf(hasConfluenceEnv())(
  "Markdown Tools — Integration",
  { timeout: 120_000 },
  () => {
    let client: ConfluenceClient;

    // Track page IDs for cleanup
    const createdPageIds: number[] = [];

    beforeAll(() => {
      const config = getConfig();
      client = new ConfluenceClient(config);
    });

    // afterAll(async () => {
    //   // Clean up all pages created during tests
    //   for (const pageId of createdPageIds) {
    //     try {
    //       await handlePageTool(client, "confluence_delete_page", {
    //         pageId,
    //       });
    //     } catch (e) {
    //       console.error(`Cleanup: failed to delete page ${pageId}:`, e);
    //     }
    //   }
    // });

    // ── Storage Format Tools ───────────────────────────────────────────────

    describe("Storage format (confluence_*_from_markdown)", () => {
      let pageId: string;

      it("should create a page from markdown", { timeout: 30_000 }, async () => {
        const result = (await handlePageTool(
          client,
          "confluence_create_page_from_markdown",
          {
            spaceId: SPACE_ID,
            title: `[IT] Storage Markdown - ${TIMESTAMP}`,
            markdown: simpleMermaidMarkdown,
          }
        )) as PageResult;

        expect(result.id).toBeDefined();
        expect(result.title).toBe(
          `[IT] Storage Markdown - ${TIMESTAMP}`
        );
        expect(result.status).toBe("current");
        expect(result.spaceId).toBe(SPACE_ID);

        pageId = result.id;
        createdPageIds.push(Number(pageId));
      });

      it("should read back the page with storage body containing Confluence macros", { timeout: 30_000 }, async () => {
        const result = (await handlePageTool(
          client,
          "confluence_get_page",
          {
            pageId: Number(pageId),
            bodyFormat: "storage",
          }
        )) as PageResult;

        expect(result.id).toBe(pageId);
        const body = result.body?.storage?.value ?? "";

        // Should contain Confluence code macros (not <pre><code>)
        expect(body).toContain('ac:name="code"');

        // Should have mermaid language parameter
        expect(body).toContain("mermaid");

        // Should contain headings
        expect(body).toContain("<h1>");
        expect(body).toContain("<h2>");

        // Should contain table
        expect(body).toContain("<table>");

        // Should contain the horizontal rule
        expect(body).toContain("<hr");
      });

      it("should update the page from markdown", { timeout: 30_000 }, async () => {
        const result = (await handlePageTool(
          client,
          "confluence_update_page_from_markdown",
          {
            pageId,
            title: `[IT] Storage Markdown Updated - ${TIMESTAMP}`,
            markdown: updateMarkdown,
            version: 1,
            versionMessage: "Updated by integration test",
          }
        )) as PageResult;

        expect(result.id).toBe(pageId);
        expect(result.title).toBe(
          `[IT] Storage Markdown Updated - ${TIMESTAMP}`
        );
        expect(result.version.number).toBe(2);
      });

      it("should read back updated content", { timeout: 30_000 }, async () => {
        const result = (await handlePageTool(
          client,
          "confluence_get_page",
          {
            pageId: Number(pageId),
            bodyFormat: "storage",
          }
        )) as PageResult;

        const body = result.body?.storage?.value ?? "";

        // Updated content should be present
        expect(body).toContain("Updated Page");
        expect(body).toContain("<strong>updated</strong>");
        expect(body).toContain("<li>Item A</li>");
        expect(body).toContain("<blockquote>");
      });
    });

    // ── ADF Format Tools ───────────────────────────────────────────────────

    describe("ADF format (confluence_*_from_markdown_adf)", () => {
      let pageId: string;

      it("should create a page from markdown via ADF", { timeout: 30_000 }, async () => {
        const result = (await handlePageTool(
          client,
          "confluence_create_page_from_markdown_adf",
          {
            spaceId: SPACE_ID,
            title: `[IT] ADF Markdown - ${TIMESTAMP}`,
            markdown: simpleMermaidMarkdown,
          }
        )) as PageResult;

        expect(result.id).toBeDefined();
        expect(result.title).toBe(
          `[IT] ADF Markdown - ${TIMESTAMP}`
        );
        expect(result.status).toBe("current");
        expect(result.spaceId).toBe(SPACE_ID);

        pageId = result.id;
        createdPageIds.push(Number(pageId));
      });

      it("should read back the page with ADF body containing mermaid codeBlock", { timeout: 30_000 }, async () => {
        const result = (await handlePageTool(
          client,
          "confluence_get_page",
          {
            pageId: Number(pageId),
            bodyFormat: "atlas_doc_format",
          }
        )) as PageResult;

        expect(result.id).toBe(pageId);
        const adfValue = result.body?.atlas_doc_format?.value ?? "";
        const adfDoc = JSON.parse(adfValue);

        expect(adfDoc.type).toBe("doc");
        expect(adfDoc.version).toBe(1);

        // Find codeBlock nodes
        const codeBlocks = adfDoc.content.filter(
          (n: { type: string }) => n.type === "codeBlock"
        );
        expect(codeBlocks.length).toBeGreaterThanOrEqual(2); // mermaid + typescript

        // Should have a mermaid codeBlock
        const mermaidBlock = codeBlocks.find(
          (n: { attrs?: { language?: string } }) =>
            n.attrs?.language === "mermaid"
        );
        expect(mermaidBlock).toBeDefined();

        // Should have headings
        const headings = adfDoc.content.filter(
          (n: { type: string }) => n.type === "heading"
        );
        expect(headings.length).toBeGreaterThan(0);

        // Should have a table
        const tables = adfDoc.content.filter(
          (n: { type: string }) => n.type === "table"
        );
        expect(tables.length).toBeGreaterThanOrEqual(1);
      });

      it("should update the page from markdown via ADF", { timeout: 30_000 }, async () => {
        const result = (await handlePageTool(
          client,
          "confluence_update_page_from_markdown_adf",
          {
            pageId,
            title: `[IT] ADF Markdown Updated - ${TIMESTAMP}`,
            markdown: updateMarkdown,
            version: 1,
            versionMessage: "Updated by integration test (ADF)",
          }
        )) as PageResult;

        expect(result.id).toBe(pageId);
        expect(result.title).toBe(
          `[IT] ADF Markdown Updated - ${TIMESTAMP}`
        );
        expect(result.version.number).toBe(2);
      });

      it("should read back updated ADF content", { timeout: 30_000 }, async () => {
        const result = (await handlePageTool(
          client,
          "confluence_get_page",
          {
            pageId: Number(pageId),
            bodyFormat: "atlas_doc_format",
          }
        )) as PageResult;

        const adfValue = result.body?.atlas_doc_format?.value ?? "";
        const adfDoc = JSON.parse(adfValue);

        // Should have a heading with "Updated Page"
        const headings = adfDoc.content.filter(
          (n: { type: string }) => n.type === "heading"
        );
        const h1 = headings.find(
          (n: { attrs?: { level?: number } }) => n.attrs?.level === 1
        );
        expect(h1).toBeDefined();

        // Should have a bulletList
        const lists = adfDoc.content.filter(
          (n: { type: string }) => n.type === "bulletList"
        );
        expect(lists.length).toBeGreaterThanOrEqual(1);

        // Should have a blockquote
        const blockquotes = adfDoc.content.filter(
          (n: { type: string }) => n.type === "blockquote"
        );
        expect(blockquotes.length).toBeGreaterThanOrEqual(1);
      });
    });

    // ── Large Document Test ────────────────────────────────────────────────

    describe("Large markdown document (real test data)", () => {
      let storagePageId: string;
      let adfPageId: string;

      it("should create a page from a large markdown file (storage)", { timeout: 30_000 }, async () => {
        const result = (await handlePageTool(
          client,
          "confluence_create_page_from_markdown",
          {
            spaceId: SPACE_ID,
            title: `[IT] Large Doc Storage - ${TIMESTAMP}`,
            markdown: shortMarkdown,
          }
        )) as PageResult;

        expect(result.id).toBeDefined();
        storagePageId = result.id;
        createdPageIds.push(Number(storagePageId));
      });

      it("should create a page from a large markdown file (ADF)", { timeout: 30_000 }, async () => {
        const result = (await handlePageTool(
          client,
          "confluence_create_page_from_markdown_adf",
          {
            spaceId: SPACE_ID,
            title: `[IT] Large Doc ADF - ${TIMESTAMP}`,
            markdown: shortMarkdown,
          }
        )) as PageResult;

        expect(result.id).toBeDefined();
        adfPageId = result.id;
        createdPageIds.push(Number(adfPageId));
      });

      it("should read back the large storage page with expected structure", { timeout: 30_000 }, async () => {
        const result = (await handlePageTool(
          client,
          "confluence_get_page",
          {
            pageId: Number(storagePageId),
            bodyFormat: "storage",
          }
        )) as PageResult;

        const body = result.body?.storage?.value ?? "";

        expect(body).toContain("<h1>");
        expect(body).toContain("<h2>");
        expect(body).toContain("<h3>");
        expect(body).toContain("<ul>");
        expect(body).toContain("<li>");
        expect(body).toContain("<strong>");
        expect(body).toContain("<table>");
      });

      it("should read back the large ADF page with expected structure", { timeout: 30_000 }, async () => {
        const result = (await handlePageTool(
          client,
          "confluence_get_page",
          {
            pageId: Number(adfPageId),
            bodyFormat: "atlas_doc_format",
          }
        )) as PageResult;

        const adfValue = result.body?.atlas_doc_format?.value ?? "";
        const adfDoc = JSON.parse(adfValue);

        expect(adfDoc.type).toBe("doc");

        // Should have headings
        const headings = adfDoc.content.filter(
          (n: { type: string }) => n.type === "heading"
        );
        expect(headings.length).toBeGreaterThan(3);

        // Should have lists
        const lists = adfDoc.content.filter(
          (n: { type: string }) =>
            n.type === "bulletList" || n.type === "orderedList"
        );
        expect(lists.length).toBeGreaterThan(0);

        // Should have paragraphs
        const paragraphs = adfDoc.content.filter(
          (n: { type: string }) => n.type === "paragraph"
        );
        expect(paragraphs.length).toBeGreaterThan(0);
      });
    });

    // ── Short Doc Visual Verification (no cleanup) ────────────────────────

    describe("Short doc — visual verification", () => {
      it("should create short doc page via storage format", { timeout: 30_000 }, async () => {
        const result = (await handlePageTool(
          client,
          "confluence_create_page_from_markdown",
          {
            spaceId: SPACE_ID,
            title: `[IT] Short Doc Storage - ${TIMESTAMP}`,
            markdown: shortMarkdown,
          }
        )) as PageResult;

        expect(result.id).toBeDefined();
        console.log(
          `✔ Storage page created: https://taktak.atlassian.net/wiki/spaces/Scotts/pages/${result.id}`
        );
      });

      it("should create short doc page via ADF format", { timeout: 30_000 }, async () => {
        const result = (await handlePageTool(
          client,
          "confluence_create_page_from_markdown_adf",
          {
            spaceId: SPACE_ID,
            title: `[IT] Short Doc ADF - ${TIMESTAMP}`,
            markdown: shortMarkdown,
          }
        )) as PageResult;

        expect(result.id).toBeDefined();
        console.log(
          `✔ ADF page created: https://taktak.atlassian.net/wiki/spaces/Scotts/pages/${result.id}`
        );
      });
    });

    // ── Long Doc Visual Verification (no cleanup) ─────────────────────────

    describe("Long doc — visual verification", () => {
      it("should create long doc page via storage format", { timeout: 30_000 }, async () => {
        const result = (await handlePageTool(
          client,
          "confluence_create_page_from_markdown",
          {
            spaceId: SPACE_ID,
            title: `[IT] Long Doc Storage - ${TIMESTAMP}`,
            markdown: longMarkdown,
          }
        )) as PageResult;

        expect(result.id).toBeDefined();
        console.log(
          `✔ Storage page created: https://taktak.atlassian.net/wiki/spaces/Scotts/pages/${result.id}`
        );
      });

      it("should create long doc page via ADF format", { timeout: 30_000 }, async () => {
        const result = (await handlePageTool(
          client,
          "confluence_create_page_from_markdown_adf",
          {
            spaceId: SPACE_ID,
            title: `[IT] Long Doc ADF - ${TIMESTAMP}`,
            markdown: longMarkdown,
          }
        )) as PageResult;

        expect(result.id).toBeDefined();
        console.log(
          `✔ ADF page created: https://taktak.atlassian.net/wiki/spaces/Scotts/pages/${result.id}`
        );
      });
    });

    // ── Create then Update with different content ──────────────────────────

    describe("Long doc — create then update", () => {
      let storagePageId: string;
      let adfPageId: string;

      const addendum = `

---

# Season 36 Update

## New Characters

| Character        | Voice Actor    | First Appearance | Role                          |
| ---------------- | -------------- | ---------------- | ----------------------------- |
| Dr. Zander       | Guest star     | S36E03           | Lisa's new science teacher    |
| Bongo the Dog    | Sound effects  | S36E07           | Santa's Little Helper's rival |

## Updated Town Map

\`\`\`mermaid
graph LR
    subgraph "New Springfield"
        Mall[Springfield Mall v2]
        Gym[Rainier Wolfcastle's Gym]
        Cafe[Starbox Coffee]
    end

    subgraph "Classic Springfield"
        Moes[Moe's Tavern]
        Kwik[Kwik-E-Mart]
        School[Springfield Elementary]
    end

    Mall --> Cafe
    Gym --> Mall
    Moes --> Kwik
    School --> Kwik
\`\`\`

## Season Ratings

1. **Episode 3** — *"Lisa Goes to Space Camp"* — **9/10**
2. **Episode 7** — *"The Dog Days of Springfield"* — **7/10**
3. **Episode 12** — *"Homer's NFT"* — **4/10** (controversial)

> *"Even after 36 seasons, this show still has the occasional gem."* — TV Guide

---

*Updated: ${TIMESTAMP}*
`;

      it("should create long doc (storage), then update with addendum", { timeout: 60_000 }, async () => {
        const createResult = (await handlePageTool(
          client,
          "confluence_create_page_from_markdown",
          {
            spaceId: SPACE_ID,
            title: `[IT] Springfield + Update (Storage) - ${TIMESTAMP}`,
            markdown: longMarkdown,
          }
        )) as PageResult;

        expect(createResult.id).toBeDefined();
        storagePageId = createResult.id;

        const updateResult = (await handlePageTool(
          client,
          "confluence_update_page_from_markdown",
          {
            pageId: storagePageId,
            title: `[IT] Springfield + Update (Storage) - ${TIMESTAMP}`,
            markdown: longMarkdown + addendum,
            version: 1,
            versionMessage: "Added Season 36 update",
          }
        )) as PageResult;

        expect(updateResult.version.number).toBe(2);
        console.log(
          `✔ Storage page created & updated: https://taktak.atlassian.net/wiki/spaces/Scotts/pages/${storagePageId}`
        );
      });

      it("should create long doc (ADF), then update with addendum", { timeout: 60_000 }, async () => {
        const createResult = (await handlePageTool(
          client,
          "confluence_create_page_from_markdown_adf",
          {
            spaceId: SPACE_ID,
            title: `[IT] Springfield + Update (ADF) - ${TIMESTAMP}`,
            markdown: longMarkdown,
          }
        )) as PageResult;

        expect(createResult.id).toBeDefined();
        adfPageId = createResult.id;

        const updateResult = (await handlePageTool(
          client,
          "confluence_update_page_from_markdown_adf",
          {
            pageId: adfPageId,
            title: `[IT] Springfield + Update (ADF) - ${TIMESTAMP}`,
            markdown: longMarkdown + addendum,
            version: 1,
            versionMessage: "Added Season 36 update",
          }
        )) as PageResult;

        expect(updateResult.version.number).toBe(2);
        console.log(
          `✔ ADF page created & updated: https://taktak.atlassian.net/wiki/spaces/Scotts/pages/${adfPageId}`
        );
      });
    });
  }
);
